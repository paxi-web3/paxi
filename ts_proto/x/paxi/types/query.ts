// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.21.12
// source: x/paxi/types/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Coin } from "../../../cosmos/base/v1beta1/coin";

export const protobufPackage = "x.paxi.types";

export interface QueryLockedVestingRequest {
}

export interface QueryLockedVestingResponse {
  amount?: Coin | undefined;
}

export interface QueryCirculatingSupplyRequest {
}

export interface QueryCirculatingSupplyResponse {
  amount?: Coin | undefined;
}

export interface QueryTotalSupplyRequest {
}

export interface QueryTotalSupplyResponse {
  amount?: Coin | undefined;
}

export interface QueryEstimatedGasPriceRequest {
}

export interface QueryEstimatedGasPriceResponse {
  gasPrice: string;
}

export interface QueryLastBlockGasUsedRequest {
}

export interface QueryLastBlockGasUsedResponse {
  gasUsed: Long;
}

export interface QueryTotalTxsRequest {
}

export interface QueryTotalTxsResponse {
  totalTxs: Long;
}

export interface UnlockSchedule {
  address: string;
  timeStr: string;
  timeUnix: Long;
  amount: Long;
  denom: string;
}

export interface QueryUnlockSchedulesRequest {
}

export interface QueryUnlockSchedulesResponse {
  unlockSchedules: UnlockSchedule[];
}

export interface QueryParamsRequest {
}

export interface QueryParamsResponse {
  extraGasPerNewAccount: Long;
}

function createBaseQueryLockedVestingRequest(): QueryLockedVestingRequest {
  return {};
}

export const QueryLockedVestingRequest: MessageFns<QueryLockedVestingRequest> = {
  encode(_: QueryLockedVestingRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLockedVestingRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLockedVestingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryLockedVestingRequest {
    return {};
  },

  toJSON(_: QueryLockedVestingRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLockedVestingRequest>, I>>(base?: I): QueryLockedVestingRequest {
    return QueryLockedVestingRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLockedVestingRequest>, I>>(_: I): QueryLockedVestingRequest {
    const message = createBaseQueryLockedVestingRequest();
    return message;
  },
};

function createBaseQueryLockedVestingResponse(): QueryLockedVestingResponse {
  return { amount: undefined };
}

export const QueryLockedVestingResponse: MessageFns<QueryLockedVestingResponse> = {
  encode(message: QueryLockedVestingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLockedVestingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLockedVestingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLockedVestingResponse {
    return { amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined };
  },

  toJSON(message: QueryLockedVestingResponse): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLockedVestingResponse>, I>>(base?: I): QueryLockedVestingResponse {
    return QueryLockedVestingResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLockedVestingResponse>, I>>(object: I): QueryLockedVestingResponse {
    const message = createBaseQueryLockedVestingResponse();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseQueryCirculatingSupplyRequest(): QueryCirculatingSupplyRequest {
  return {};
}

export const QueryCirculatingSupplyRequest: MessageFns<QueryCirculatingSupplyRequest> = {
  encode(_: QueryCirculatingSupplyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCirculatingSupplyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCirculatingSupplyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryCirculatingSupplyRequest {
    return {};
  },

  toJSON(_: QueryCirculatingSupplyRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCirculatingSupplyRequest>, I>>(base?: I): QueryCirculatingSupplyRequest {
    return QueryCirculatingSupplyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCirculatingSupplyRequest>, I>>(_: I): QueryCirculatingSupplyRequest {
    const message = createBaseQueryCirculatingSupplyRequest();
    return message;
  },
};

function createBaseQueryCirculatingSupplyResponse(): QueryCirculatingSupplyResponse {
  return { amount: undefined };
}

export const QueryCirculatingSupplyResponse: MessageFns<QueryCirculatingSupplyResponse> = {
  encode(message: QueryCirculatingSupplyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryCirculatingSupplyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryCirculatingSupplyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryCirculatingSupplyResponse {
    return { amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined };
  },

  toJSON(message: QueryCirculatingSupplyResponse): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryCirculatingSupplyResponse>, I>>(base?: I): QueryCirculatingSupplyResponse {
    return QueryCirculatingSupplyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryCirculatingSupplyResponse>, I>>(
    object: I,
  ): QueryCirculatingSupplyResponse {
    const message = createBaseQueryCirculatingSupplyResponse();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseQueryTotalSupplyRequest(): QueryTotalSupplyRequest {
  return {};
}

export const QueryTotalSupplyRequest: MessageFns<QueryTotalSupplyRequest> = {
  encode(_: QueryTotalSupplyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTotalSupplyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTotalSupplyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryTotalSupplyRequest {
    return {};
  },

  toJSON(_: QueryTotalSupplyRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTotalSupplyRequest>, I>>(base?: I): QueryTotalSupplyRequest {
    return QueryTotalSupplyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTotalSupplyRequest>, I>>(_: I): QueryTotalSupplyRequest {
    const message = createBaseQueryTotalSupplyRequest();
    return message;
  },
};

function createBaseQueryTotalSupplyResponse(): QueryTotalSupplyResponse {
  return { amount: undefined };
}

export const QueryTotalSupplyResponse: MessageFns<QueryTotalSupplyResponse> = {
  encode(message: QueryTotalSupplyResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.amount !== undefined) {
      Coin.encode(message.amount, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTotalSupplyResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTotalSupplyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.amount = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTotalSupplyResponse {
    return { amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined };
  },

  toJSON(message: QueryTotalSupplyResponse): unknown {
    const obj: any = {};
    if (message.amount !== undefined) {
      obj.amount = Coin.toJSON(message.amount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTotalSupplyResponse>, I>>(base?: I): QueryTotalSupplyResponse {
    return QueryTotalSupplyResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTotalSupplyResponse>, I>>(object: I): QueryTotalSupplyResponse {
    const message = createBaseQueryTotalSupplyResponse();
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Coin.fromPartial(object.amount)
      : undefined;
    return message;
  },
};

function createBaseQueryEstimatedGasPriceRequest(): QueryEstimatedGasPriceRequest {
  return {};
}

export const QueryEstimatedGasPriceRequest: MessageFns<QueryEstimatedGasPriceRequest> = {
  encode(_: QueryEstimatedGasPriceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEstimatedGasPriceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEstimatedGasPriceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryEstimatedGasPriceRequest {
    return {};
  },

  toJSON(_: QueryEstimatedGasPriceRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEstimatedGasPriceRequest>, I>>(base?: I): QueryEstimatedGasPriceRequest {
    return QueryEstimatedGasPriceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEstimatedGasPriceRequest>, I>>(_: I): QueryEstimatedGasPriceRequest {
    const message = createBaseQueryEstimatedGasPriceRequest();
    return message;
  },
};

function createBaseQueryEstimatedGasPriceResponse(): QueryEstimatedGasPriceResponse {
  return { gasPrice: "" };
}

export const QueryEstimatedGasPriceResponse: MessageFns<QueryEstimatedGasPriceResponse> = {
  encode(message: QueryEstimatedGasPriceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gasPrice !== "") {
      writer.uint32(10).string(message.gasPrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryEstimatedGasPriceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryEstimatedGasPriceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gasPrice = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryEstimatedGasPriceResponse {
    return { gasPrice: isSet(object.gasPrice) ? globalThis.String(object.gasPrice) : "" };
  },

  toJSON(message: QueryEstimatedGasPriceResponse): unknown {
    const obj: any = {};
    if (message.gasPrice !== "") {
      obj.gasPrice = message.gasPrice;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryEstimatedGasPriceResponse>, I>>(base?: I): QueryEstimatedGasPriceResponse {
    return QueryEstimatedGasPriceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryEstimatedGasPriceResponse>, I>>(
    object: I,
  ): QueryEstimatedGasPriceResponse {
    const message = createBaseQueryEstimatedGasPriceResponse();
    message.gasPrice = object.gasPrice ?? "";
    return message;
  },
};

function createBaseQueryLastBlockGasUsedRequest(): QueryLastBlockGasUsedRequest {
  return {};
}

export const QueryLastBlockGasUsedRequest: MessageFns<QueryLastBlockGasUsedRequest> = {
  encode(_: QueryLastBlockGasUsedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLastBlockGasUsedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLastBlockGasUsedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryLastBlockGasUsedRequest {
    return {};
  },

  toJSON(_: QueryLastBlockGasUsedRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLastBlockGasUsedRequest>, I>>(base?: I): QueryLastBlockGasUsedRequest {
    return QueryLastBlockGasUsedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLastBlockGasUsedRequest>, I>>(_: I): QueryLastBlockGasUsedRequest {
    const message = createBaseQueryLastBlockGasUsedRequest();
    return message;
  },
};

function createBaseQueryLastBlockGasUsedResponse(): QueryLastBlockGasUsedResponse {
  return { gasUsed: Long.UZERO };
}

export const QueryLastBlockGasUsedResponse: MessageFns<QueryLastBlockGasUsedResponse> = {
  encode(message: QueryLastBlockGasUsedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.gasUsed.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.gasUsed.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryLastBlockGasUsedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryLastBlockGasUsedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.gasUsed = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryLastBlockGasUsedResponse {
    return { gasUsed: isSet(object.gasUsed) ? Long.fromValue(object.gasUsed) : Long.UZERO };
  },

  toJSON(message: QueryLastBlockGasUsedResponse): unknown {
    const obj: any = {};
    if (!message.gasUsed.equals(Long.UZERO)) {
      obj.gasUsed = (message.gasUsed || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryLastBlockGasUsedResponse>, I>>(base?: I): QueryLastBlockGasUsedResponse {
    return QueryLastBlockGasUsedResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryLastBlockGasUsedResponse>, I>>(
    object: I,
  ): QueryLastBlockGasUsedResponse {
    const message = createBaseQueryLastBlockGasUsedResponse();
    message.gasUsed = (object.gasUsed !== undefined && object.gasUsed !== null)
      ? Long.fromValue(object.gasUsed)
      : Long.UZERO;
    return message;
  },
};

function createBaseQueryTotalTxsRequest(): QueryTotalTxsRequest {
  return {};
}

export const QueryTotalTxsRequest: MessageFns<QueryTotalTxsRequest> = {
  encode(_: QueryTotalTxsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTotalTxsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTotalTxsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryTotalTxsRequest {
    return {};
  },

  toJSON(_: QueryTotalTxsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTotalTxsRequest>, I>>(base?: I): QueryTotalTxsRequest {
    return QueryTotalTxsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTotalTxsRequest>, I>>(_: I): QueryTotalTxsRequest {
    const message = createBaseQueryTotalTxsRequest();
    return message;
  },
};

function createBaseQueryTotalTxsResponse(): QueryTotalTxsResponse {
  return { totalTxs: Long.UZERO };
}

export const QueryTotalTxsResponse: MessageFns<QueryTotalTxsResponse> = {
  encode(message: QueryTotalTxsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.totalTxs.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.totalTxs.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTotalTxsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTotalTxsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalTxs = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTotalTxsResponse {
    return { totalTxs: isSet(object.totalTxs) ? Long.fromValue(object.totalTxs) : Long.UZERO };
  },

  toJSON(message: QueryTotalTxsResponse): unknown {
    const obj: any = {};
    if (!message.totalTxs.equals(Long.UZERO)) {
      obj.totalTxs = (message.totalTxs || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTotalTxsResponse>, I>>(base?: I): QueryTotalTxsResponse {
    return QueryTotalTxsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTotalTxsResponse>, I>>(object: I): QueryTotalTxsResponse {
    const message = createBaseQueryTotalTxsResponse();
    message.totalTxs = (object.totalTxs !== undefined && object.totalTxs !== null)
      ? Long.fromValue(object.totalTxs)
      : Long.UZERO;
    return message;
  },
};

function createBaseUnlockSchedule(): UnlockSchedule {
  return { address: "", timeStr: "", timeUnix: Long.ZERO, amount: Long.ZERO, denom: "" };
}

export const UnlockSchedule: MessageFns<UnlockSchedule> = {
  encode(message: UnlockSchedule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.timeStr !== "") {
      writer.uint32(18).string(message.timeStr);
    }
    if (!message.timeUnix.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timeUnix.toString());
    }
    if (!message.amount.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.amount.toString());
    }
    if (message.denom !== "") {
      writer.uint32(42).string(message.denom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnlockSchedule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlockSchedule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeStr = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timeUnix = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.amount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnlockSchedule {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      timeStr: isSet(object.timeStr) ? globalThis.String(object.timeStr) : "",
      timeUnix: isSet(object.timeUnix) ? Long.fromValue(object.timeUnix) : Long.ZERO,
      amount: isSet(object.amount) ? Long.fromValue(object.amount) : Long.ZERO,
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
    };
  },

  toJSON(message: UnlockSchedule): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.timeStr !== "") {
      obj.timeStr = message.timeStr;
    }
    if (!message.timeUnix.equals(Long.ZERO)) {
      obj.timeUnix = (message.timeUnix || Long.ZERO).toString();
    }
    if (!message.amount.equals(Long.ZERO)) {
      obj.amount = (message.amount || Long.ZERO).toString();
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnlockSchedule>, I>>(base?: I): UnlockSchedule {
    return UnlockSchedule.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnlockSchedule>, I>>(object: I): UnlockSchedule {
    const message = createBaseUnlockSchedule();
    message.address = object.address ?? "";
    message.timeStr = object.timeStr ?? "";
    message.timeUnix = (object.timeUnix !== undefined && object.timeUnix !== null)
      ? Long.fromValue(object.timeUnix)
      : Long.ZERO;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? Long.fromValue(object.amount)
      : Long.ZERO;
    message.denom = object.denom ?? "";
    return message;
  },
};

function createBaseQueryUnlockSchedulesRequest(): QueryUnlockSchedulesRequest {
  return {};
}

export const QueryUnlockSchedulesRequest: MessageFns<QueryUnlockSchedulesRequest> = {
  encode(_: QueryUnlockSchedulesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUnlockSchedulesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnlockSchedulesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryUnlockSchedulesRequest {
    return {};
  },

  toJSON(_: QueryUnlockSchedulesRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnlockSchedulesRequest>, I>>(base?: I): QueryUnlockSchedulesRequest {
    return QueryUnlockSchedulesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnlockSchedulesRequest>, I>>(_: I): QueryUnlockSchedulesRequest {
    const message = createBaseQueryUnlockSchedulesRequest();
    return message;
  },
};

function createBaseQueryUnlockSchedulesResponse(): QueryUnlockSchedulesResponse {
  return { unlockSchedules: [] };
}

export const QueryUnlockSchedulesResponse: MessageFns<QueryUnlockSchedulesResponse> = {
  encode(message: QueryUnlockSchedulesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.unlockSchedules) {
      UnlockSchedule.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUnlockSchedulesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUnlockSchedulesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.unlockSchedules.push(UnlockSchedule.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUnlockSchedulesResponse {
    return {
      unlockSchedules: globalThis.Array.isArray(object?.unlockSchedules)
        ? object.unlockSchedules.map((e: any) => UnlockSchedule.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryUnlockSchedulesResponse): unknown {
    const obj: any = {};
    if (message.unlockSchedules?.length) {
      obj.unlockSchedules = message.unlockSchedules.map((e) => UnlockSchedule.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUnlockSchedulesResponse>, I>>(base?: I): QueryUnlockSchedulesResponse {
    return QueryUnlockSchedulesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUnlockSchedulesResponse>, I>>(object: I): QueryUnlockSchedulesResponse {
    const message = createBaseQueryUnlockSchedulesResponse();
    message.unlockSchedules = object.unlockSchedules?.map((e) => UnlockSchedule.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { extraGasPerNewAccount: Long.UZERO };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.extraGasPerNewAccount.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.extraGasPerNewAccount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.extraGasPerNewAccount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return {
      extraGasPerNewAccount: isSet(object.extraGasPerNewAccount)
        ? Long.fromValue(object.extraGasPerNewAccount)
        : Long.UZERO,
    };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (!message.extraGasPerNewAccount.equals(Long.UZERO)) {
      obj.extraGasPerNewAccount = (message.extraGasPerNewAccount || Long.UZERO).toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.extraGasPerNewAccount =
      (object.extraGasPerNewAccount !== undefined && object.extraGasPerNewAccount !== null)
        ? Long.fromValue(object.extraGasPerNewAccount)
        : Long.UZERO;
    return message;
  },
};

export interface Query {
  LockedVesting(request: QueryLockedVestingRequest): Promise<QueryLockedVestingResponse>;
  CirculatingSupply(request: QueryCirculatingSupplyRequest): Promise<QueryCirculatingSupplyResponse>;
  TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse>;
  EstimatedGasPrice(request: QueryEstimatedGasPriceRequest): Promise<QueryEstimatedGasPriceResponse>;
  LastBlockGasUsed(request: QueryLastBlockGasUsedRequest): Promise<QueryLastBlockGasUsedResponse>;
  TotalTxs(request: QueryTotalTxsRequest): Promise<QueryTotalTxsResponse>;
  UnlockSchedules(request: QueryUnlockSchedulesRequest): Promise<QueryUnlockSchedulesResponse>;
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
}

export const QueryServiceName = "x.paxi.types.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.LockedVesting = this.LockedVesting.bind(this);
    this.CirculatingSupply = this.CirculatingSupply.bind(this);
    this.TotalSupply = this.TotalSupply.bind(this);
    this.EstimatedGasPrice = this.EstimatedGasPrice.bind(this);
    this.LastBlockGasUsed = this.LastBlockGasUsed.bind(this);
    this.TotalTxs = this.TotalTxs.bind(this);
    this.UnlockSchedules = this.UnlockSchedules.bind(this);
    this.Params = this.Params.bind(this);
  }
  LockedVesting(request: QueryLockedVestingRequest): Promise<QueryLockedVestingResponse> {
    const data = QueryLockedVestingRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LockedVesting", data);
    return promise.then((data) => QueryLockedVestingResponse.decode(new BinaryReader(data)));
  }

  CirculatingSupply(request: QueryCirculatingSupplyRequest): Promise<QueryCirculatingSupplyResponse> {
    const data = QueryCirculatingSupplyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CirculatingSupply", data);
    return promise.then((data) => QueryCirculatingSupplyResponse.decode(new BinaryReader(data)));
  }

  TotalSupply(request: QueryTotalSupplyRequest): Promise<QueryTotalSupplyResponse> {
    const data = QueryTotalSupplyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TotalSupply", data);
    return promise.then((data) => QueryTotalSupplyResponse.decode(new BinaryReader(data)));
  }

  EstimatedGasPrice(request: QueryEstimatedGasPriceRequest): Promise<QueryEstimatedGasPriceResponse> {
    const data = QueryEstimatedGasPriceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EstimatedGasPrice", data);
    return promise.then((data) => QueryEstimatedGasPriceResponse.decode(new BinaryReader(data)));
  }

  LastBlockGasUsed(request: QueryLastBlockGasUsedRequest): Promise<QueryLastBlockGasUsedResponse> {
    const data = QueryLastBlockGasUsedRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LastBlockGasUsed", data);
    return promise.then((data) => QueryLastBlockGasUsedResponse.decode(new BinaryReader(data)));
  }

  TotalTxs(request: QueryTotalTxsRequest): Promise<QueryTotalTxsResponse> {
    const data = QueryTotalTxsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TotalTxs", data);
    return promise.then((data) => QueryTotalTxsResponse.decode(new BinaryReader(data)));
  }

  UnlockSchedules(request: QueryUnlockSchedulesRequest): Promise<QueryUnlockSchedulesResponse> {
    const data = QueryUnlockSchedulesRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UnlockSchedules", data);
    return promise.then((data) => QueryUnlockSchedulesResponse.decode(new BinaryReader(data)));
  }

  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
